# ============================================================================
# CI/CD Workflow - Microservice Deployment
#
# 각 리포지토리마다 수정 필요:
# 1. Line 25-29: SERVICE_NAME, PARAMETER_PATH 수정
# 2. Line 49: 환경변수 리스트 수정 (추가/삭제)
# ============================================================================

name: ecs CI/CD

on:
  push:
    branches:
      - main
      - dev
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-2
  GITHUB_USERNAME: ${{ github.actor }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # ⚠️⚠️⚠️ 필수 수정 사항 - 각 리포지토리마다 다름 ⚠️⚠️⚠️
  SERVICE_NAME: user                                    # ← hub, order, user, gateway, eureka
  PARAMETER_PATH: /jumunhasyeo/dev/user/               # ← 서비스 이름 변경
  ECR_REPOSITORY: jumunhasyeo-dev-user                 # ← 서비스 이름 변경
  ECS_SERVICE: jumunhasyeo-dev-user                    # ← 서비스 이름 변경
  # ⚠️⚠️⚠️ 위 4개 값만 수정하면 됩니다 ⚠️⚠️⚠️

  # 아래는 공통 (수정 불필요)
  ECS_CLUSTER: jumunhasyeo-dev-cluster

jobs:
  # ==========================================================================
  # Job 1: Build and Test
  # ==========================================================================
  build-test:
    name: Build and Test
    runs-on: ubuntu-latest
    # ⚠️⚠️⚠️ 필수 수정 사항 - 각 리포지토리마다 다름 ⚠️⚠️⚠
    environment: user-cicd

    services:
      docker:
        image: docker:dind
        options: --privileged

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Create application.yml from sample
        run: |
          cp src/main/resources/application-sample.yml src/main/resources/application.yml
          echo "application.yml created from sample"

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      # ⚠️⚠️⚠️ 필수 수정 사항 - 각 리포지토리마다 다름 테스트를 위한 환경변수 ⚠️⚠️⚠️
      - name: Run tests
        if: true == false # TEST skip
        run: ./gradlew test
        env:
          POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USERNAME: ${{ secrets.POSTGRES_USERNAME }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          PASSPORT_ALGORITHM: ${{ secrets.PASSPORT_ALGORITHM }}
          PASSPORT_EXP: ${{ secrets.PASSPORT_EXP }}
          PASSPORT_KEY: ${{ secrets.PASSPORT_KEY }}
          KAFKA_SERVER: ${{ secrets.KAFKA_SERVER }}
          GROUP_ID: ${{ secrets.GROUP_ID }}
          EUREKA_SERVER: ${{ secrets.EUREKA_SERVER }}
          JWT_KEY: ${{ secrets.JWT_KEY }}
          SLACK_API_KEY: ${{ secrets.SLACK_API_KEY}}

          # Testcontainers 설정
          TESTCONTAINERS_RYUK_DISABLED: false
          TESTCONTAINERS_CHECKS_DISABLE: false

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: build/libs/*.jar
          retention-days: 1

  # ==========================================================================
  # Job 2: Build and Push Docker Image
  # ==========================================================================
  build-push-image:
    name: Build and Push Docker Image
    environment: user-aws
    runs-on: ubuntu-latest
    needs: build-test
#    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')

    outputs:
      image-tag: ${{ steps.image-info.outputs.image-tag }}
      image-uri: ${{ steps.image-info.outputs.image-uri }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: build/libs/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image tag
        id: image-info
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          if [ "$BRANCH_NAME" == "main" ]; then
            IMAGE_TAG="prod-${SHORT_SHA}-${TIMESTAMP}"
          else
            IMAGE_TAG="dev-${SHORT_SHA}-${TIMESTAMP}"
          fi
          
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image-uri=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Build and Push Docker image
        env:
          GITHUB_USERNAME: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image-info.outputs.image-tag }}
        run: |
          docker build \
            --build-arg JAR_FILE=build/libs/*.jar \
            --build-arg GITHUB_USERNAME=$GITHUB_USERNAME \
            --build-arg GITHUB_TOKEN=$GITHUB_TOKEN \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  # ==========================================================================
  # Job 3: Deploy to ECS
  # ==========================================================================
  deploy-ecs:
    name: Deploy to ECS
    environment: user-aws
    runs-on: ubuntu-latest
    needs: build-push-image
#    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      #  Parameter Store에서 환경변수 가져오기
      - name: Fetch environment variables from Parameter Store
        id: fetch-params
        run: |
          echo "✅ Fetching parameters from $PARAMETER_PATH..."
          
          aws ssm get-parameters-by-path \
            --path "$PARAMETER_PATH" \
            --recursive \
            --with-decryption \
            --region $AWS_REGION \
            --output json > parameters.json
          
          PARAM_COUNT=$(jq '.Parameters | length' parameters.json)
          echo "✅ Fetched $PARAM_COUNT parameters"

      # 현재 Task Definition 가져오기
      - name: Download current task definition
        run: |
          aws ecs describe-task-definition \
            --task-definition $ECS_SERVICE \
            --query taskDefinition \
            > task-definition.json

      # Parameter Store 값을 환경변수로 변환하여 주입
      #
      #  환경변수 추가/삭제 시:
      # Parameter Store에 직접 추가/삭제 후 재배포하면 자동 반영됨
      # 예시: aws ssm put-parameter --name "/jumunhasyeo/dev/hub/NEW_VAR" --value "value" --type String
      #
      - name: Inject environment variables into Task Definition
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import sys
          
          with open('task-definition.json', 'r') as f:
              task_def = json.load(f)
          
          with open('parameters.json', 'r') as f:
              params_data = json.load(f)
          
          # Parameter Store → 환경변수 변환
          env_vars = []
          for param in params_data.get('Parameters', []):
              key = param['Name'].split('/')[-1]
              value = param['Value']
              env_vars.append({"name": key, "value": value})
          
          # 컨테이너 찾기
          container = task_def['containerDefinitions'][0]
          container['environment'] = env_vars
          
          # 불필요한 필드 제거
          for key in ['taskDefinitionArn', 'revision', 'status', 
                      'requiresAttributes', 'compatibilities', 
                      'registeredAt', 'registeredBy']:
              task_def.pop(key, None)
          
          with open('task-definition-updated.json', 'w') as f:
              json.dump(task_def, f, indent=2)
          
          print(f" Injected {len(env_vars)} environment variables")
          PYTHON_SCRIPT

      # 새 이미지로 업데이트
      - name: Update task definition with new image
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition-updated.json
          container-name: ${{ env.SERVICE_NAME }}
          image: ${{ needs.build-push-image.outputs.image-uri }}

      # ECS 배포
      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Verify deployment
        run: |
          echo " ${{ env.SERVICE_NAME }} deployed successfully!"
          echo "Image: ${{ needs.build-push-image.outputs.image-uri }}"
